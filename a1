local CoreGui = game:GetService("CoreGui")
local Players = game:GetService("Players")
local HttpService = game:GetService("HttpService")
local RunService = game:GetService("RunService")

-- Ensure LocalPlayer is available
local LocalPlayer = Players.LocalPlayer
if not LocalPlayer then
    warn("[SETUP] LocalPlayer not found initially. Waiting...")
    local playerAddedConnection
    if not Players.LocalPlayer then -- Ensure it wasn't set while checking
        playerAddedConnection = Players.PlayerAdded:Connect(function(player)
            if player == Players.LocalPlayer then -- Check if the added player is the LocalPlayer
                LocalPlayer = player
                if playerAddedConnection then
                    playerAddedConnection:Disconnect()
                    playerAddedConnection = nil
                    print("[SETUP] LocalPlayer detected via PlayerAdded event:", LocalPlayer.Name)
                end
            end
        end)
        -- Wait for a bit if LocalPlayer isn't immediately available
        if not Players.LocalPlayer then
            for i = 1, 50 do -- Wait up to 5 seconds
                if Players.LocalPlayer then break end
                task.wait(0.1)
            end
        end
        LocalPlayer = Players.LocalPlayer
        if playerAddedConnection and LocalPlayer then playerAddedConnection:Disconnect() end
    end


    if not LocalPlayer then
        error("[SETUP_ERROR] Executor Error: LocalPlayer could not be found after waiting. Cannot create GUI.")
        return
    else
        print("[SETUP] LocalPlayer found:", LocalPlayer.Name)
    end
end


-- Create a ScreenGui
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "ExecutorLoadingScreenGUI_v4_" .. string.sub(HttpService:GenerateGUID(false), 1, 8)
screenGui.IgnoreGuiInset = false -- IMPORTANT: false to respect Roblox's default UI space (top bar)
screenGui.ResetOnSpawn = false
screenGui.DisplayOrder = 2147483646 -- High, but should be below Roblox ESC menu (often 2147483647)
screenGui.Parent = CoreGui
print("[GUI_SETUP] ScreenGui created. Name: ", screenGui.Name, ". Parent: ", screenGui.Parent)
print("[GUI_SETUP] IgnoreGuiInset: ", screenGui.IgnoreGuiInset)
print("[GUI_SETUP] DisplayOrder: ", screenGui.DisplayOrder)

-- Create a background Frame
local backgroundFrame = Instance.new("Frame")
backgroundFrame.Name = "Background"
backgroundFrame.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
backgroundFrame.BorderSizePixel = 0
backgroundFrame.Size = UDim2.new(1, 0, 1, 0)
backgroundFrame.Parent = screenGui

local backgroundCorner = Instance.new("UICorner")
backgroundCorner.CornerRadius = UDim.new(0, 12) -- Rounded corners for the main background
backgroundCorner.Parent = backgroundFrame

-- Create a container for loading elements
local loadingContainer = Instance.new("Frame")
loadingContainer.Name = "LoadingContainer"
loadingContainer.BackgroundTransparency = 1
loadingContainer.Size = UDim2.new(0.7, 0, 0.45, 0)
loadingContainer.Position = UDim2.new(0.5, 0, 0.5, 0)
loadingContainer.AnchorPoint = Vector2.new(0.5, 0.5)
loadingContainer.Parent = backgroundFrame

-- Create a title TextLabel
local titleLabel = Instance.new("TextLabel")
titleLabel.Name = "Title"
titleLabel.Text = "LOADING..."
titleLabel.Font = Enum.Font.Cartoon
titleLabel.TextColor3 = Color3.fromRGB(220, 220, 220)
titleLabel.TextSize = 55
titleLabel.TextStrokeTransparency = 0.5
titleLabel.TextStrokeColor3 = Color3.fromRGB(20,20,20)
titleLabel.BackgroundTransparency = 1
titleLabel.Size = UDim2.new(1, 0, 0.25, 0)
titleLabel.Position = UDim2.new(0.5, 0, 0.15, 0)
titleLabel.AnchorPoint = Vector2.new(0.5, 0.5)
titleLabel.Parent = loadingContainer

-- Create the "VelvetHub Scripts [BGSI]" TextLabel with Gradient
local brandLabel = Instance.new("TextLabel")
brandLabel.Name = "BrandLabel"
brandLabel.Text = "VelvetHub Scripts [BGSI]"
brandLabel.Font = Enum.Font.GothamSemibold
brandLabel.TextSize = 32
brandLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
brandLabel.BackgroundTransparency = 1
brandLabel.Size = UDim2.new(1, 0, 0.2, 0)
brandLabel.Position = UDim2.new(0.5, 0, 0.42, 0)
brandLabel.AnchorPoint = Vector2.new(0.5, 0.5)
brandLabel.Parent = loadingContainer

local brandGradient = Instance.new("UIGradient")
brandGradient.Color = ColorSequence.new({
    ColorSequenceKeypoint.new(0, Color3.fromRGB(170, 0, 255)),
    ColorSequenceKeypoint.new(0.5, Color3.fromRGB(255, 0, 170)),
    ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 100, 0))
})
brandGradient.Rotation = 45
brandGradient.Parent = brandLabel

-- Create a loading bar background
local loadingBarBackground = Instance.new("Frame")
loadingBarBackground.Name = "LoadingBarBackground"
loadingBarBackground.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
loadingBarBackground.BorderColor3 = Color3.fromRGB(20,20,20)
loadingBarBackground.BorderSizePixel = 2
loadingBarBackground.Size = UDim2.new(0.9, 0, 0.15, 0)
loadingBarBackground.Position = UDim2.new(0.5, 0, 0.75, 0)
loadingBarBackground.AnchorPoint = Vector2.new(0.5, 0.5)
loadingBarBackground.Parent = loadingContainer

local UICornerForBar = Instance.new("UICorner")
UICornerForBar.CornerRadius = UDim.new(0, 8)
UICornerForBar.Parent = loadingBarBackground

local loadingBarFill = Instance.new("Frame")
loadingBarFill.Name = "LoadingBarFill"
loadingBarFill.BackgroundColor3 = Color3.fromRGB(70, 130, 180)
loadingBarFill.BorderSizePixel = 0
loadingBarFill.Size = UDim2.new(0, 0, 1, 0)
loadingBarFill.Parent = loadingBarBackground

local UICornerForFill = Instance.new("UICorner")
UICornerForFill.CornerRadius = UDim.new(0, 8)
UICornerForFill.Parent = loadingBarFill

local percentageLabel = Instance.new("TextLabel")
percentageLabel.Name = "PercentageLabel"
percentageLabel.Text = "0%"
percentageLabel.Font = Enum.Font.Cartoon
percentageLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
percentageLabel.TextSize = 28
percentageLabel.BackgroundTransparency = 1
percentageLabel.Size = UDim2.new(1, 0, 1, 0)
percentageLabel.Position = UDim2.new(0.5, 0, 0.5, 0)
percentageLabel.AnchorPoint = Vector2.new(0.5, 0.5)
percentageLabel.ZIndex = loadingBarBackground.ZIndex + 1
percentageLabel.Parent = loadingBarBackground
print("[GUI_SETUP] All GUI elements created and parented.")

-- The URL for the script to load
local scriptUrl = "loadstring(game:HttpGet("https://raw.githubusercontent.com/IdiotHub/Scripts/refs/heads/main/BGSI/main.lua"))()"
local scriptContent = nil

-- Coroutine to execute the external script
local function executeExternalScript()
    print("[SCRIPT_EXEC] Starting executeExternalScript coroutine.")

    -- Simple loadstring self-test
    print("[SCRIPT_EXEC] Performing loadstring self-test...")
    local testFunc, testErr = loadstring("print('[LOADSTRING_TEST] Simple loadstring self-test successful!')")
    if testFunc then
        local successTest, errTest = pcall(testFunc)
        if not successTest then
            print("[LOADSTRING_TEST_ERROR] Self-test pcall failed:", errTest)
        end
    else
        print("[LOADSTRING_TEST_ERROR] Self-test loadstring compilation failed:", testErr)
        warn("[SCRIPT_EXEC_WARN] Loadstring functionality might be disabled or broken in this environment.")
        -- It might still be worth trying the main script if only the test format was an issue
    end

    local success, result = pcall(function()
        print("[SCRIPT_EXEC] Attempting to fetch script from URL:", scriptUrl)
        local fetched = false

        -- Method 1: Using game:HttpGetAsync
        print("[HTTP_FETCH] Trying game:HttpGetAsync...")
        local canFetch, fetchResultOrContent = pcall(function()
            return game:HttpGetAsync(scriptUrl, true)
        end)
        if canFetch and type(fetchResultOrContent) == "string" and #fetchResultOrContent > 0 then
            scriptContent = fetchResultOrContent
            fetched = true
            print("[HTTP_FETCH] Successfully fetched script content using game:HttpGetAsync. Length:", #scriptContent)
        else
            warn("[HTTP_FETCH_WARN] game:HttpGetAsync failed or returned empty. CanFetch:",官员canFetch, "Reason/Type:", fetchResultOrContent)
        end

        -- Method 2: Check for common executor HttpGet
        if not fetched and typeof(HttpGet) == "function" then
             print("[HTTP_FETCH] Trying common executor's HttpGet function...")
             local executorFetchSuccess, executorFetchContent = pcall(HttpGet, scriptUrl)
             if executorFetchSuccess and type(executorFetchContent) == "string" and #executorFetchContent > 0 then
                 scriptContent = executorFetchContent
                 fetched = true
                 print("[HTTP_FETCH] Successfully fetched script content using executor's HttpGet. Length:", #scriptContent)
             else
                 warn("[HTTP_FETCH_WARN] Executor's HttpGet failed or returned empty. Success:", executorFetchSuccess, "Reason/Type:", executorFetchContent)
             end
        end
        
        -- Method 3: Check for syn.request
        if not fetched and syn and typeof(syn.request) == "function" then
            print("[HTTP_FETCH] Trying syn.request function...")
            local synRequestSuccess, synRequestResultObj = pcall(function()
                return syn.request({Url = scriptUrl, Method = "GET"})
            end)
            if synRequestSuccess and synRequestResultObj and type(synRequestResultObj.Body) == "string" and #synRequestResultObj.Body > 0 then
                scriptContent = synRequestResultObj.Body
                fetched = true
                print("[HTTP_FETCH] Successfully fetched script content using syn.request. Length:", #scriptContent)
            else
                 warn("[HTTP_FETCH_WARN] syn.request failed or returned empty body. Success:", synRequestSuccess, "Result:", synRequestResultObj)
            end
        end

        if not fetched or not scriptContent or #scriptContent == 0 then
            warn("[SCRIPT_EXEC_ERROR] FAILED to fetch script from URL using all available methods or content is empty.")
            warn("[SCRIPT_EXEC_ERROR] Ensure your executor supports HTTP requests and the game allows them (if using game:HttpGetAsync),")
            warn("[SCRIPT_EXEC_ERROR] or paste the script content manually into the 'scriptContent' variable in this script.")
            -- FALLBACK: scriptContent = [[ -- Paste your Lua script content here -- ]]
            if not scriptContent or #scriptContent == 0 then return end -- Exit if no script content
        end

        print("[SCRIPT_EXEC] Script content fetched. Attempting loadstring compilation...")
        local scriptFunction, loadError = loadstring(scriptContent)
        if scriptFunction then
            print("[SCRIPT_EXEC] Loadstring compilation successful. Executing the loaded script now in a new coroutine...")
            task.spawn(function() -- Execute in its own coroutine so it doesn't halt loading screen if it yields/errors
                print("[LOADED_SCRIPT] Attempting to run pcall on the function from loadstring.")
                local execSuccess, execError = pcall(scriptFunction)
                if not execSuccess then
                    warn("[LOADED_SCRIPT_ERROR] Error executing loaded script:", execError)
                else
                    print("[LOADED_SCRIPT] External script executed successfully via loadstring.")
                end
            end)
        else
            warn("[SCRIPT_EXEC_ERROR] Loadstring compilation failed:", loadError)
        end
    end)

    if not success then
        warn("[SCRIPT_EXEC_FATAL] An error occurred within the executeExternalScript pcall wrapper itself:", result)
    end
end

task.spawn(executeExternalScript) -- This ensures GUI is already visible when script execution starts
print("[INIT] External script execution process initiated via task.spawn().")

-- Animate the loading bar
local targetPercentage = 99
local currentPercentage = 0
local loadingDuration = 4
local startTime = tick()
local animationConnection

animationConnection = RunService.RenderStepped:Connect(function(deltaTime)
    if not screenGui or not screenGui.Parent then
        if animationConnection then
            animationConnection:Disconnect()
            animationConnection = nil
        end
        return
    end

    if currentPercentage >= targetPercentage then
        percentageLabel.Text = "99%"
        loadingBarFill.Size = UDim2.new(0.99, 0, 1, 0)
        
        if animationConnection then
            animationConnection:Disconnect()
            animationConnection = nil
            print("[ANIMATION] Loading screen reached 99%. Animation stopped. GUI will remain.")
        end
        return
    end

    local elapsedTime = tick() - startTime
    currentPercentage = math.min(math.floor((elapsedTime / loadingDuration) * targetPercentage), targetPercentage)

    loadingBarFill.Size = UDim2.new(currentPercentage / 100, 0, 1, 0)
    percentageLabel.Text = tostring(currentPercentage) .. "%"
end)
